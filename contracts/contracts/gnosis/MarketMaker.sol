// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ERC1155Holder } from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";
import { CTHelpers } from "./CTHelpers.sol";
import { ConditionalTokens } from "./ConditionalTokens.sol";
import { Whitelist } from "./Whitelist.sol";

abstract contract MarketMaker is Ownable, ERC1155Holder {
    constructor() Ownable(msg.sender) {}

    /*
     *  Constants
     */    
    uint64 public constant FEE_RANGE = 10**18; 

    /*
     *  Events
     */
    event AMMCreated(uint initialFunding);
    event AMMPaused();
    event AMMResumed();
    event AMMClosed();
    event AMMFundingChanged(int fundingChange);
    event AMMFeeChanged(uint64 newFee);
    event AMMFeeWithdrawal(uint fees);
    event AMMOutcomeTokenTrade(address indexed transactor, int[] outcomeTokenAmounts, int outcomeTokenNetCost, uint marketFees);
    
    /*
     *  Storage
     */
    ConditionalTokens public pmSystem;
    IERC20 public collateralToken;
    bytes32[] public conditionIds;
    uint public atomicOutcomeSlotCount;
    uint64 public fee;
    uint public funding;
    Stage public stage;
    Whitelist public whitelist;

    uint[] outcomeSlotCounts;
    bytes32[][] collectionIds;
    uint[] positionIds;

    enum Stage {
        Running,
        Paused,
        Closed
    }

    /*
     *  Modifiers
     */
    modifier atStage(Stage _stage) {
        // Contract has to be in given stage
        require(stage == _stage, "Invalid stage");
        _;
    }

    modifier onlyWhitelisted() {
        require(
            whitelist == Whitelist(address(0)) || whitelist.isWhitelisted(msg.sender),
            "Only whitelisted users may call this function"
        );
        _;
    }

    function calcNetCost(int[] memory outcomeTokenAmounts) public virtual view returns (int netCost);

    /// @dev Allows to fund the market with collateral tokens converting them into outcome tokens
    function changeFunding(int fundingChange)
        public
        onlyOwner
        atStage(Stage.Paused)
    {
        require(fundingChange != 0, "Funding change must be non-zero");

        if (fundingChange > 0) {
            require(
                collateralToken.transferFrom(msg.sender, address(this), uint(fundingChange)) &&
                collateralToken.approve(address(pmSystem), uint(fundingChange)),
                "Transfer or approval failed"
            );

            splitPositionThroughAllConditions(uint(fundingChange));
            funding += uint(fundingChange);  
            emit AMMFundingChanged(fundingChange);
        }

        if (fundingChange < 0) {
            mergePositionsThroughAllConditions(uint(-fundingChange));
            funding -= uint(-fundingChange);  
            require(collateralToken.transfer(owner(), uint(-fundingChange)), "Transfer failed");
            emit AMMFundingChanged(fundingChange);
        }
    }

    function pause() public onlyOwner atStage(Stage.Running) {
        stage = Stage.Paused;
        emit AMMPaused();
    }
    
    function resume() public onlyOwner atStage(Stage.Paused) {
        stage = Stage.Running;
        emit AMMResumed();
    }

    function changeFee(uint64 _fee) public onlyOwner atStage(Stage.Paused) {
        fee = _fee;
        emit AMMFeeChanged(fee);
    }

    /// @dev Allows market owner to close the markets by transferring all remaining outcome tokens to the owner
    function close()
        public
        onlyOwner
    {
        require(stage == Stage.Running || stage == Stage.Paused, "Market already closed");
        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {
            uint positionId = generateAtomicPositionId(i);
            uint balance = pmSystem.balanceOf(address(this), positionId);
            pmSystem.safeTransferFrom(address(this), owner(), positionId, balance, "");
        }
        stage = Stage.Closed;
        emit AMMClosed();
    }

    /// @dev Allows market owner to withdraw fees generated by trades
    /// @return fees Fee amount
    function withdrawFees()
        public
        onlyOwner
        returns (uint fees)
    {
        fees = collateralToken.balanceOf(address(this));
        require(collateralToken.transfer(owner(), fees), "Fee withdrawal failed");
        emit AMMFeeWithdrawal(fees);
    }

    /// @dev Allows to trade outcome tokens and collateral with the market maker
    function trade(int[] memory outcomeTokenAmounts, int collateralLimit)
        public
        atStage(Stage.Running)
        onlyWhitelisted
        returns (int netCost)
    {
        require(outcomeTokenAmounts.length == atomicOutcomeSlotCount, "Invalid outcome token length");

        int outcomeTokenNetCost = calcNetCost(outcomeTokenAmounts);
        int fees = outcomeTokenNetCost < 0 
            ? int(calcMarketFee(uint(-outcomeTokenNetCost))) 
            : int(calcMarketFee(uint(outcomeTokenNetCost)));

        require(fees >= 0, "Invalid fees");
        netCost = outcomeTokenNetCost + fees;  

        require(
            (collateralLimit != 0 && netCost <= collateralLimit) || collateralLimit == 0,
            "Collateral limit exceeded"
        );

        if (outcomeTokenNetCost > 0) {
            require(
                collateralToken.transferFrom(msg.sender, address(this), uint(netCost)) &&
                collateralToken.approve(address(pmSystem), uint(outcomeTokenNetCost)),
                "Transfer or approval failed"
            );

            splitPositionThroughAllConditions(uint(outcomeTokenNetCost));
        }

        bool touched = false;
        uint[] memory transferAmounts = new uint[](atomicOutcomeSlotCount);
        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {
            if (outcomeTokenAmounts[i] < 0) {
                touched = true;
                transferAmounts[i] = uint(-outcomeTokenAmounts[i]);
            }
        }
        if (touched) {
            pmSystem.safeBatchTransferFrom(msg.sender, address(this), positionIds, transferAmounts, "");
        }

        if (outcomeTokenNetCost < 0) {
            mergePositionsThroughAllConditions(uint(-outcomeTokenNetCost));
        }

        emit AMMOutcomeTokenTrade(msg.sender, outcomeTokenAmounts, outcomeTokenNetCost, uint(fees));

        touched = false;
        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {
            if (outcomeTokenAmounts[i] > 0) {
                touched = true;
                transferAmounts[i] = uint(outcomeTokenAmounts[i]);
            } else {
                transferAmounts[i] = 0;
            }
        }
        if (touched) {
            pmSystem.safeBatchTransferFrom(address(this), msg.sender, positionIds, transferAmounts, "");
        }

        if (netCost < 0) {
            require(collateralToken.transfer(msg.sender, uint(-netCost)), "Collateral transfer failed");
        }
    }

    /// @dev Calculates fee to be paid to market maker
    function calcMarketFee(uint outcomeTokenCost)
        public
        view
        returns (uint)
    {
        return (outcomeTokenCost * fee) / FEE_RANGE;
    }

    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }

    function generateBasicPartition(uint outcomeSlotCount)
        private
        pure
        returns (uint[] memory partition)
    {
        partition = new uint[](outcomeSlotCount);
        for (uint i = 0; i < outcomeSlotCount; i++) {
            partition[i] = 1 << i;
        }
    }

    function generateAtomicPositionId(uint i)
        internal
        view
        returns (uint)
    {
        return positionIds[i];
    }

    function splitPositionThroughAllConditions(uint amount)
        private
    {
        for (uint i = conditionIds.length; i > 0; i--) {
            uint index = i - 1;
            uint[] memory partition = generateBasicPartition(outcomeSlotCounts[index]);
            for (uint j = 0; j < collectionIds[index].length; j++) {
                pmSystem.splitPosition(collateralToken, collectionIds[index][j], conditionIds[index], partition, amount);
            }
        }
    }

    function mergePositionsThroughAllConditions(uint amount)
        private
    {
        for (uint i = 0; i < conditionIds.length; i++) {
            uint[] memory partition = generateBasicPartition(outcomeSlotCounts[i]);
            for (uint j = 0; j < collectionIds[i].length; j++) {
                pmSystem.mergePositions(collateralToken, collectionIds[i][j], conditionIds[i], partition, amount);
            }
        }
    }
}
